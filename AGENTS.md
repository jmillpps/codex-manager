# AGENTS.md

## System instructions

You must always keep this agents file up to date. As the project changes, you must ensure these agents instructions are kept up to date.

Record all new information and documentation under docs/ and treat this directory like your personal curated knowledge base, not a dumping ground. The moment a document starts serving more than one clear purpose, it’s time to split it. A good rule of thumb: if a file exceeds 500 lines or contains multiple top‑level concerns (e.g., “architecture + protocol details + operational runbooks”), extract each concern into its own document and replace the removed sections with short summaries and links. Prefer a shallow, predictable structure (e.g., architecture/, protocol/, operations/, adr/) over giant monolithic files. Each document should answer one primary question (“How does the App Server protocol work?” vs “How do I run this locally?”), and its filename should reflect that question. Avoid appending to the end of existing docs out of convenience—if new content introduces a new conceptual boundary, create a new file and cross-reference it instead. Periodically refactor documentation just like code: remove duplication, consolidate overlapping sections, reorganize scattered related information, and delete obsolete content rather than marking it “deprecated.” Clean documentation scales when structure is intentional, scope is narrow, and ownership of each document is explicit.

At the end of every turn, you must perform a Documentation Impact Assessment by determining whether anything in that turn changed the system’s external behavior, public surface, lifecycle semantics, configuration requirements, operational steps, or user workflow. Report the result as your own assessment (not as a question to the user). If the answer is yes, documentation must be updated in the same commit; if the answer is no, no documentation changes are required. If a competent developer reading the existing docs would form a different mental model than the system now implements, the docs are wrong and must be corrected immediately. Documentation hygiene is as important as development.

Keep default runs clean:

- Runtime and test artifacts must be written under `.data/` (or another gitignored runtime path), not into tracked source directories.
- Playwright/Vitest/other report outputs must never be committed.
- Root report/state directories such as `test-results/`, `playwright-report/`, `blob-report/`, and `coverage/` are treated as ephemeral and must remain untracked.

## Brief

This project is a local-first Codex chat application in active implementation, with a runnable React/Vite frontend and Fastify backend that supervise and bridge `codex app-server` over STDIO for session lifecycle, streaming responses, and approval decisions while keeping Codex as the authoritative runtime.

## Repository context

This repository contains both planning documents and active implementation code:

- `apps/web`: React + Vite chat UI with ChatGPT-like split-pane layout, project/chat navigation and management flows, consolidated turn rendering (user request + unified response card with progressive thought disclosure), markdown-rendered assistant responses and thought reasoning/message previews (including collapsible bold-title subsections inside expanded thought details), approvals/tool-input inline handling, a pinned per-chat `Session Controls` panel (scope-aware Apply/Revert workflow for `model`, `approval policy`, `network access`, and `filesystem sandbox`, embedded supervisor file-change controls persisted under session settings (`Diff Explainability`, `Auto Approve`, `Auto Reject`, `Auto Steer` with per-action thresholds), immediate per-chat `Thinking Level` selector, hover-descriptive tooltips for summary/selector values, lock-aware default scope behavior, default/after-apply summary-chip collapse, and `Close` primary action when no tuple edits are pending), canonical protocol approval-policy controls (`untrusted`/`on-failure`/`on-request`/`never`), queue-backed suggest-request integration (single-flight pending guard + websocket completion application), explainability transcript rendering for completed file-change diffs, thread actions/insights/settings surfaces, websocket-backed streaming lifecycle UX, disconnected-chat reconnect overlay UX, optimistic outgoing-message delivery-state indicators (`Sending`/`Sent`/`Delivered`/`Failed`), incoming response receive-state indicators (spinner while streaming, disconnect marker on drop), a completion checkmark on final assistant replies, live transcript rendering from current state (no top-level transcript memo cache), and session-switch race guards that prevent stale transcript/approval/tool-input hydration from leaking prior-chat content, duplicating delivered user bubbles, or dropping newer websocket approval/tool-input requests during in-flight REST hydration. Detailed behavior contracts (including scroll anchoring/snap-back tuning and approval rendering semantics) are documented in `docs/implementation-status.md`.
- `apps/api`: Fastify backend supervising `codex app-server` over STDIO with session/project lifecycle APIs, thread/turn control endpoints, approvals/tool-input/dynamic-tool-call workflows (`GET /api/sessions/:sessionId/tool-calls`, `POST /api/tool-calls/:requestId/response`; duplicate in-flight responses return `409 code: in_flight`), dynamic tool registration passthrough on session create/resume/send payloads (`dynamicTools` with required `inputSchema` forwarded to thread lifecycle calls), queue-backed suggested-request + file-change explainability orchestration jobs, hidden system-owned orchestrator session isolation, metadata persistence (including supplemental transcript ledger and orchestrator job store), websocket fan-out, deterministic typed extension event dispatch (including app-server signal pass-through families under `app_server.*` with normalized names and shared envelope/session metadata, plus supervisor-driven initial default-title rename jobs), runtime profile adapter boundaries, extension lifecycle endpoints (`GET /api/agents/extensions`, `POST /api/agents/extensions/reload`) with RBAC/trust controls (disabled/header/jwt), semver-based compatibility enforcement, reload audit logging, portable-extension conformance harness support, and structured error mapping. Session-mutating control routes are existence-gated to avoid orphan per-session control metadata writes, and dedicated generic settings routes (`GET|POST /api/sessions/:sessionId/settings`, `DELETE /api/sessions/:sessionId/settings/:key`) provide per-session/per-default key/value storage consumed by UI/CLI/extensions. Detailed runtime semantics and endpoint behavior contracts are documented in `docs/implementation-status.md`.
- `apps/cli`: workspace CLI (`@repo/cli`) that provides endpoint-complete operator access to API/websocket workflows with profile-based runtime/auth defaults, command-domain grouping, and API route parity tests.
- `packages/agent-runtime-sdk`: canonical provider-neutral runtime SDK contracts for extension events/tools/typed emit envelopes and reconciliation helper utilities.
- `packages/api-client`: generated TypeScript API client for health, session/project lifecycle, bulk project operations, project agent-session listings, session controls + generic session settings helpers, approvals/tool-input decisions, dynamic tool-call list/response helpers, thread actions, and settings/account/integration surfaces
- `packages/python-client`: Python SDK for codex-manager control-plane APIs + websocket stream automation, including sync/async clients, decorator-based event handlers, request hooks, protocol-based dependency injection (executor/header/retry/hook-registry/router/plugin), deterministic plugin lifecycle orchestration, middleware object registration, session-scoped settings helpers, sync/async wait helpers (`wait.until(...)`, `wait.send_message_and_wait_reply(...)`), dynamic tool-call wrappers (`sessions.tool_calls`, `tool_calls.respond`), remote-skill session bridge utilities (`remote_skills.session(...)`, `remote_skills.create_session(...)`, auto `dynamic_tools` forwarding on `send(...)`, catalog readiness helpers `prepare_catalog(...)` / `send_prepared(...)`, pending-call polling fallback via `drain_pending_calls(...)`, and `sync_runtime(...)` lifecycle sync), runnable multi-agent coordination example (`examples/team_mesh.py`), and an additive OpenAPI-typed facade (`cm.typed`, `acm.typed`) backed by generated Pydantic request/response models
- root dev tooling includes Playwright browser smoke/e2e commands (`pnpm test:e2e*`) routed through `scripts/run-playwright.mjs` (Linux shared-library bootstrap into `.data/playwright-libs` when needed, and test output under `.data/playwright-test-results`) plus a runtime integration smoke harness (`pnpm smoke:runtime`) for API + websocket lifecycle validation
- host-level API supervision helper script `scripts/install-api-user-service.sh` installs a user-level `systemd` unit (`codex-manager-api.service`) with restart-on-failure semantics for always-on local API availability
- `docs/*`: product, architecture, protocol, operations, and implementation-status documentation organized as focused knowledge-tree modules

## Document guide

- `docs/prd.md`: L1 product foundation and scope boundaries.
- `docs/product/core-prd-requirements.md`: L2 core functional/technical/UX requirements.
- `docs/product/core-prd-delivery-and-risk.md`: L2 milestones, metrics, and risk posture.
- `docs/product/agent-platform-requirements.md`: L2 extension-platform release requirements.
- `docs/architecture.md`: L1 system boundary, topology, and invariants.
- `docs/architecture/agent-extension-runtime.md`: L2 extension-runtime architecture and governance controls.
- `docs/codex-app-server.md`: L1 protocol map for app-server and harness contracts.
- `docs/protocol/overview.md`, `docs/protocol/methods-core.md`, `docs/protocol/methods-integrations.md`, `docs/protocol/events.md`, `docs/protocol/harness-runtime-events.md`: L2 protocol guides.
- `docs/protocol/overview-transport-and-handshake.md`, `docs/protocol/overview-primitives-and-capabilities.md`, `docs/protocol/methods-core-threads-and-turns.md`, `docs/protocol/methods-core-review-and-advanced-thread.md`, `docs/protocol/methods-integrations-discovery-and-skills.md`, `docs/protocol/methods-integrations-config-and-account.md`, `docs/protocol/events-catalog.md`, `docs/protocol/events-item-types-and-deltas.md`, `docs/protocol/harness-runtime-event-catalog.md`, `docs/protocol/harness-runtime-websocket-and-transcript.md`: L3 protocol deep references.
- `docs/protocol/agent-runtime-sdk.md`, `docs/protocol/agent-dispatch-and-reconciliation.md`, `docs/protocol/agent-extension-packaging.md`, `docs/protocol/approvals-and-tool-input.md`, `docs/protocol/config-security-and-client-rules.md`: protocol contracts used by API/extensions.
- `docs/ops.md`: L1 operations index.
- `docs/operations/setup-and-run.md`, `docs/operations/environment-reference.md`, `docs/operations/cli.md`, `docs/operations/troubleshooting.md`, `docs/operations/generation-and-validation.md`, `docs/operations/release-gate-checklist.md`, `docs/operations/api-service-supervision.md`, `docs/operations/agent-extension-authoring.md`, `docs/operations/agent-extension-lifecycle-and-conformance.md`, `docs/operations/agent-queue-framework.md`, `docs/operations/agent-queue-troubleshooting.md`, `docs/operations/maintenance.md`: L2 operations runbooks.
- `docs/operations/cli-command-reference.md`, `docs/operations/cli-workflow-playbooks.md`, `docs/operations/generation-command-reference.md`, `docs/operations/validation-gate-playbook.md`, `docs/operations/troubleshooting-api-auth-runtime.md`, `docs/operations/troubleshooting-web-stream-state.md`, `docs/operations/agent-extension-authoring-manifest-events.md`, `docs/operations/agent-extension-authoring-worker-jobs.md`, `docs/operations/agent-extension-lifecycle-rbac-trust.md`, `docs/operations/agent-extension-conformance-audit.md`, `docs/operations/agent-queue-event-and-job-contracts.md`, `docs/operations/agent-queue-runtime-semantics.md`: L3 operations deep references.
- `docs/queue-runner.md`: L2 queue-runner worker guidance.
- `docs/queue-runner-capability-reference.md`: L3 queue-runner capability details.
- `docs/python/introduction.md`: L1 Python SDK entrypoint.
- `docs/python/quickstart.md`, `docs/python/practical-recipes.md`, `docs/python/team-mesh.md`, `docs/python/api-surface.md`, `docs/python/streaming-and-handlers.md`, `docs/python/remote-skills.md`, `docs/python/settings-and-automation.md`, `docs/python/protocol-interfaces.md`, `docs/python/typed-models.md`, `docs/python/development-and-packaging.md`: L2 Python guides.
- `docs/python/api-surface-domain-reference.md`, `docs/python/api-surface-workflows.md`, `docs/python/streaming-event-routing-reference.md`, `docs/python/streaming-reliability-patterns.md`, `docs/python/remote-skills-lifecycle-and-catalog.md`, `docs/python/remote-skills-dispatch-and-reliability.md`, `docs/python/protocol-interfaces-contracts.md`, `docs/python/protocol-interfaces-examples.md`, `docs/python/typed-models-contract-reference.md`, `docs/python/typed-models-validation-and-gates.md`: L3 Python deep references.
- `docs/implementation-status.md`: L1 implementation snapshot index.
- `docs/implementation-status-api.md`, `docs/implementation-status-web-cli.md`, `docs/implementation-status-python-contracts.md`: L2 implementation status by surface.
- `docs/operations/agent-platform-verification-matrix.md`: requirement-to-test evidence mapping for agent platform gates.

## How to use these docs

1. Start with `docs/prd.md` for product intent and acceptance criteria.
2. Use `docs/architecture.md` to align implementation boundaries and invariants.
3. Use `docs/codex-app-server.md` as the protocol index, then traverse L2 -> L3 docs under `docs/protocol/` for the exact concern.
4. Use `docs/ops.md` as the operations index, then traverse L2 -> L3 runbooks under `docs/operations/` plus queue-runner references for execution details.
5. For Python SDK work, start with `docs/python/introduction.md` and follow L2 -> L3 Python guides for your workflow (`quickstart`, `api-surface`, `streaming-and-handlers`, `remote-skills`, `typed-models`, etc.).
6. Use `docs/implementation-status.md` and its surface-specific L2 docs to confirm what is implemented right now.
